#!/usr/bin/env python3
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

import logging

from lib.module.base import ModuleBaseClass
from lib.module.options import Options

from lib.module.safety import Safety
from lib.module.intrusiveness import Intrusiveness

logger = logging.getLogger(__name__)

class ExploitClass(ModuleBaseClass):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    # Functions to be overridden
    def exploit_code(self, payload):
        pass

    def get_badchars(self):
        return self.info.get("payload", {}).get("badchars", "")

    # Internal functions
    def set_option(self, key, value):
        self.options[key] = value

    def set_default_options(self):
        for i in self.info.get("options", []):
            self.set_option(i[0], i[2])

    def match_classification(self, level_safety, level_intrusiveness):
        """
        Check if the safety- and intrusiveness-level is within the given parameters for the specific
        module.
        """
        slevel, ilevel = self.info.get("classification", (Safety.DEFAULT, Intrusiveness.DEFAULT))
        return slevel.value <= level_safety.value and ilevel.value <= level_intrusiveness.value

    def split(self, val, delim):
        return [int(x) for x in val.split(delim)]

    def version_between(self, lower, higher, version, delim=".", match=2):
        h = self.split(higher, delim)
        l = self.split(lower, delim)
        v = self.split(version, delim)

        # Higher and lower must be same length
        assert len(h) == len(l)

        # We normalize version number by appending zer if necessary
        for i in range(len(v), len(h)):
            v.append(0)

        # Sanity check
        assert len(v) == len(h)

        status = 0
        for i in range(0, len(v)):
            if status & 1 != 1:   # Should check low
                if v[i] < l[i]:
                    return False
                elif v[i] > l[i]:
                    status |= 1     # Should no longer check low
            if status & 2 != 2:    # Should check high
                if v[i] > h[i]:
                    return False
                elif v[i] < h[i]:
                    status |= 2

        # Can match including or excluding lower and topper

        if match & 1 == 1 and version == lower:
            return False

        if match & 2 == 2 and version == higher:
            return False

        return True

    def match_product(self, product):
        """
        Check if exploit can be used against the detected product.

        Returns true if any of the given matches returns true. All provided options must be equal,
        in other words, if 'version' is set to a specific value, it must match. If only product is
        given, it will match any version.
        """
        # Empty search provides no results
        if len(product) == 0:
            return False

        for modproduct in self.info.get("products", []):
            match = False
            logger.debug("Checking {}".format(modproduct))
            for key, val in product.items():
                # If key doesn't exist, we continue
                if key not in modproduct:
                    continue
                elif modproduct[key] == val:
                    match = True
                else:
                    match = False
                    break
            if match == True:
                return True
        return False

    def get_ports(self):
        return self.info.get("Ports", [])
